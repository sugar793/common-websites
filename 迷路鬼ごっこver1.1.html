<!DOCTYPE html>
<html lang="ja">
<head>
 <meta charset="UTF-8" />
 <title>Ëø∑Ë∑ØÈ¨º„Åî„Å£„Åìver.1.1</title>
 <style>
   body {
     margin: 0;
     background: black;
     color: white;
     font-family: sans-serif;
     display: flex;
     justify-content: center;
     align-items: flex-start;
     height: 100vh;
   }
   canvas {
     background: #111;
     margin: 10px;
   }
   #ui {
     margin: 10px;
     min-width: 160px;
   }
   button {
     margin-top: 10px;
     font-size: 14px;
   }
   ol {
     padding-left: 20px;
     font-size: 14px;
   }
   #modal {
     position: fixed;
     top: 0; left: 0;
     width: 100%; height: 100%;
     background: rgba(0, 0, 0, 0.8);
     color: white;
     display: none;
     justify-content: center;
     align-items: center;
     flex-direction: column;
     z-index: 999;
   }
   #modal-message {
     font-size: 20px;
     margin-bottom: 30px;
     text-align: center;
     white-space: pre-line;
   }
   #modal button {
     font-size: 20px;
     padding: 12px 30px;
     cursor: pointer;
   }
 </style>
</head>
<body>
 <canvas id="game" width="600" height="600"></canvas>
 <div id="ui">
   <div>‚è± „Çø„Ç§„Éû„Éº: <span id="timer">0.0</span> Áßí</div>
   <button onclick="showShortestPath()">ÊúÄÁü≠„É´„Éº„ÉàË°®Á§∫</button>
   <button onclick="showModal('üëæ „Ç≤„Éº„É†Ë™¨Êòé\n\n„Éó„É¨„Ç§„É§„ÉºÔºàÈùíÔºâ„ÇíÊìç‰Ωú„Åó„Å¶Á∑ë„ÅÆ„Ç¥„Éº„É´„ÇíÁõÆÊåá„Åù„ÅÜÔºÅ\n\nÈ¨ºÔºàËµ§Ôºâ„Å´Êçï„Åæ„Å£„Åü„Çâ„Ç≤„Éº„É†„Ç™„Éº„Éê„ÉºÔºÅÈ¨º„ÅØËø∑Ë∑ØÈñ¢‰øÇ„Å™„ÅèËøΩ„ÅÑ„Åã„Åë„Å¶„Åç„Åæ„Åô„ÄÇ\n\nÁü¢Âç∞„Ç≠„Éº„ÇÑWASD„ÅßÁßªÂãï„Åß„Åç„Çã„Çà„ÄÇ')">„Ç≤„Éº„É†Ë™¨Êòé</button>
   <button onclick="showModal('üïπÔ∏è Ë£èÊäÄ\n\n‚Üë‚Üì‚Üê‚Üí„Ç≠„Éº„Å®WASD„ÇíÂêåÊôÇ„Å´Êäº„Åô„Å®‚Ä¶ÔºÅÔºü')">Ë£èÊäÄ</button>
   <h3>üèÜ „É©„É≥„Ç≠„É≥„Ç∞</h3>
   <ol id="ranking"></ol>
   <button onclick="resetRanking()">„É©„É≥„Ç≠„É≥„Ç∞„Çí„É™„Çª„ÉÉ„Éà</button>
 </div>


 <div id="modal">
   <div id="modal-message"></div>
   <button onclick="restartGame()">OK</button>
 </div>


 <script>
   const canvas = document.getElementById("game");
   const ctx = canvas.getContext("2d");
   const cols = 20, rows = 20, cellSize = 30;
   const goal = { x: cols - 1, y: 0 };
   const start = { x: 0, y: 0 };
   let grid = [], stack = [];
   let current, genInterval;
   let shortestPath = [];


   let canMove = false;


   function Cell(x, y) {
     this.x = x;
     this.y = y;
     this.walls = [true, true, true, true];
     this.visited = false;
     this.show = function () {
       const x = this.x * cellSize;
       const y = this.y * cellSize;
       ctx.strokeStyle = "#fff";
       ctx.lineWidth = 2;
       if (this.walls[0]) drawLine(x, y, x + cellSize, y);
       if (this.walls[1]) drawLine(x + cellSize, y, x + cellSize, y + cellSize);
       if (this.walls[2]) drawLine(x + cellSize, y + cellSize, x, y + cellSize);
       if (this.walls[3]) drawLine(x, y + cellSize, x, y);
     };
   }


   function drawLine(x1, y1, x2, y2) {
     ctx.beginPath();
     ctx.moveTo(x1, y1);
     ctx.lineTo(x2, y2);
     ctx.stroke();
   }


   function index(x, y) {
     if (x < 0 || y < 0 || x >= cols || y >= rows) return -1;
     return x + y * cols;
   }


   function removeWalls(a, b) {
     const dx = a.x - b.x;
     const dy = a.y - b.y;
     if (dx === 1) { a.walls[3] = false; b.walls[1] = false; }
     else if (dx === -1) { a.walls[1] = false; b.walls[3] = false; }
     if (dy === 1) { a.walls[0] = false; b.walls[2] = false; }
     else if (dy === -1) { a.walls[2] = false; b.walls[0] = false; }
   }


   function generateMaze() {
     grid = [];
     stack = [];
     for (let y = 0; y < rows; y++) {
       for (let x = 0; x < cols; x++) {
         grid.push(new Cell(x, y));
       }
     }
     current = grid[0];


     return new Promise(resolve => {
       genInterval = setInterval(() => {
         ctx.clearRect(0, 0, canvas.width, canvas.height);
         grid.forEach(c => c.show());
         current.visited = true;
         let neighbors = [];
         const dirs = [[0, -1], [1, 0], [0, 1], [-1, 0]];
         for (let [dx, dy] of dirs) {
           const neighbor = grid[index(current.x + dx, current.y + dy)];
           if (neighbor && !neighbor.visited) neighbors.push(neighbor);
         }
         if (neighbors.length > 0) {
           const next = neighbors[Math.floor(Math.random() * neighbors.length)];
           stack.push(current);
           removeWalls(current, next);
           current = next;
         } else if (stack.length > 0) {
           current = stack.pop();
         } else {
           clearInterval(genInterval);
           resolve();
         }
       }, 10);
     });
   }


   async function generateMazeUntilPathLongEnough(minLength = 120) {
     while (true) {
       await generateMaze();
       const path = bfs(start, goal);
       if (path.length >= minLength) {
         shortestPath = [];
         startGame();
         break;
       }
     }
   }


   let player = { x: 0, y: 0 };
   let oni = { x: cols - 1, y: rows - 1 };
   let oniMoveCounter = 0;
   const oniMoveInterval = 40;
   let oniActive = false;
   let nextOniPos = { x: oni.x, y: oni.y };
   let gameOver = false;
   let startTime, timerInterval;


   function startGame() {
     player.x = start.x;
     player.y = start.y;
     canMove = true;


     setTimeout(() => { oniActive = true; }, 1000);


     startTime = Date.now();
     timerInterval = setInterval(() => {
       const elapsed = (Date.now() - startTime) / 1000;
       document.getElementById("timer").textContent = elapsed.toFixed(1);
     }, 100);


     loadRanking();
     requestAnimationFrame(gameLoop);
   }


   function gameLoop() {
     drawGame();
     if (oniActive && !gameOver) {
       oniMoveCounter++;
       if (oniMoveCounter >= oniMoveInterval) {
         moveOni();
         oniMoveCounter = 0;
       }
     }
     checkWinLose();
     if (!gameOver) requestAnimationFrame(gameLoop);
   }


   function moveOni() {
     const dx = player.x - oni.x;
     const dy = player.y - oni.y;
     if (Math.abs(dx) > Math.abs(dy)) oni.x += Math.sign(dx);
     else oni.y += Math.sign(dy);
   }


   function getNextOniPos() {
     const dx = player.x - oni.x;
     const dy = player.y - oni.y;
     let nx = oni.x;
     let ny = oni.y;
     if (Math.abs(dx) > Math.abs(dy)) nx += Math.sign(dx);
     else ny += Math.sign(dy);
     return { x: nx, y: ny };
   }


   function drawGame() {
     ctx.clearRect(0, 0, canvas.width, canvas.height);
     grid.forEach(c => c.show());


     ctx.fillStyle = "rgba(0,255,0,0.4)";
     for (const step of shortestPath) {
       ctx.fillRect(step.x * cellSize + 4, step.y * cellSize + 4, 22, 22);
     }


     ctx.fillStyle = "lime";
     ctx.fillRect(goal.x * cellSize + 8, goal.y * cellSize + 8, 14, 14);


     ctx.fillStyle = "blue";
     ctx.fillRect(player.x * cellSize + 8, player.y * cellSize + 8, 14, 14);


     ctx.fillStyle = "red";
     ctx.fillRect(oni.x * cellSize + 8, oni.y * cellSize + 8, 14, 14);


     if (oniActive) {
       nextOniPos = getNextOniPos();
       ctx.fillStyle = "rgba(255,0,0,0.5)";
       ctx.fillRect(nextOniPos.x * cellSize + 10, nextOniPos.y * cellSize + 10, 10, 10);
     }
   }


   function checkWinLose() {
     if (player.x === oni.x && player.y === oni.y) {
       showModal("Êçï„Åæ„Å£„ÅüÔºÅ");
     } else if (player.x === goal.x && player.y === goal.y) {
       const time = (Date.now() - startTime) / 1000;
       saveRecord(time.toFixed(1));
       showModal(`„Ç¥„Éº„É´ÊàêÂäüÔºÅ\n\n„Çø„Ç§„É†: ${time.toFixed(1)}Áßí`);
     }
   }


   document.addEventListener("keydown", e => {
     if (!canMove || gameOver) return;


     const cell = grid[index(player.x, player.y)];
     if (e.key === "ArrowUp" || e.key === "w") {
       if (!cell.walls[0]) player.y--;
     } else if (e.key === "ArrowDown" || e.key === "s") {
       if (!cell.walls[2]) player.y++;
     } else if (e.key === "ArrowLeft" || e.key === "a") {
       if (!cell.walls[3]) player.x--;
     } else if (e.key === "ArrowRight" || e.key === "d") {
       if (!cell.walls[1]) player.x++;
     }
   });


   function showShortestPath() {
     shortestPath = bfs(player, goal);
   }


   function bfs(start, end) {
     const visited = Array(rows).fill().map(() => Array(cols).fill(false));
     const queue = [[start.x, start.y, []]];
     while (queue.length > 0) {
       const [x, y, path] = queue.shift();
       if (x === end.x && y === end.y) return path;
       visited[y][x] = true;
       const cell = grid[index(x, y)];
       const dirs = [[0, -1, 0], [1, 0, 1], [0, 1, 2], [-1, 0, 3]];
       for (const [dx, dy, dir] of dirs) {
         const nx = x + dx, ny = y + dy;
         const ni = index(nx, ny);
         if (ni >= 0 && !visited[ny][nx] && !cell.walls[dir]) {
           queue.push([nx, ny, [...path, { x: nx, y: ny }]]);
         }
       }
     }
     return [];
   }


   function saveRecord(time) {
     let records = JSON.parse(localStorage.getItem("mazeRecords") || "[]");
     records.push(parseFloat(time));
     records.sort((a, b) => a - b);
     records = records.slice(0, 5);
     localStorage.setItem("mazeRecords", JSON.stringify(records));
     loadRanking();
   }


   function loadRanking() {
     const list = document.getElementById("ranking");
     const records = JSON.parse(localStorage.getItem("mazeRecords") || "[]");
     list.innerHTML = "";
     records.forEach(t => {
       const li = document.createElement("li");
       li.textContent = `${t} Áßí`;
       list.appendChild(li);
     });
   }


   function resetRanking() {
     localStorage.removeItem("mazeRecords");
     loadRanking();
   }


   function showModal(message) {
     document.getElementById("modal-message").innerHTML = message.replace(/\n/g, "<br>");
     document.getElementById("modal").style.display = "flex";
     gameOver = true;
     clearInterval(timerInterval);
   }


   function restartGame() {
     location.reload();
   }


   generateMazeUntilPathLongEnough();
 </script>
</body>
</html>


