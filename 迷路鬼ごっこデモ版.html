<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8" />
<title>Ëø∑Ë∑ØÈ¨º„Åî„Å£„Åìver.1.3</title>
<style>
  body {
    margin: 0;
    background: black;
    color: white;
    font-family: sans-serif;
    display: flex;
    justify-content: center;
    align-items: flex-start;
    height: 100vh;
  }
  canvas {
    background: #111;
    margin: 10px;
  }
  #ui {
    margin: 10px;
    min-width: 160px;
  }
  button {
    margin-top: 10px;
    font-size: 14px;
  }
  ol {
    padding-left: 20px;
    font-size: 14px;
  }
  #modal {
    position: fixed;
    top: 0; left: 0;
    width: 100%; height: 100%;
    background: rgba(0, 0, 0, 0.8);
    color: white;
    display: none;
    justify-content: center;
    align-items: center;
    flex-direction: column;
    z-index: 999;
  }
  #modal-message {
    font-size: 20px;
    margin-bottom: 30px;
    text-align: center;
    white-space: pre-line;
  }
  #modal button {
    font-size: 20px;
    padding: 12px 30px;
    cursor: pointer;
  }
  #mini-map {
    border: 2px solid white;
    border-radius: 50%;
    background: black;
    margin-top: 20px;
  }
  #keys {
    margin-top: 20px;
  }
  .key-group {
    display: flex;
    flex-direction: column;
    align-items: center;
    margin-bottom: 20px;
  }
  .key-row {
    display: flex;
    justify-content: center;
    margin: 2px 0;
  }
  .key {
    width: 30px;
    height: 30px;
    border: 1px solid white;
    display: flex;
    align-items: center;
    justify-content: center;
    margin: 2px;
    font-size: 14px;
    background: #222;
    color: white;
  }
  .pressed {
    background: yellow;
    color: black;
  }
</style>
</head>
<body>
<canvas id="game" width="600" height="600"></canvas>
<div id="ui">
  <div>‚è± „Çø„Ç§„Éû„Éº: <span id="timer">0.0</span> Áßí</div>
  <button onclick="showShortestPath()">ÊúÄÁü≠„É´„Éº„ÉàË°®Á§∫</button>
  <h3>üèÜ „É©„É≥„Ç≠„É≥„Ç∞</h3>
  <ol id="ranking"></ol>
  <button onclick="resetRanking()">„É©„É≥„Ç≠„É≥„Ç∞„Çí„É™„Çª„ÉÉ„Éà</button>

  <canvas id="mini-map" width="150" height="150"></canvas>

  <div id="keys">
    <div class="key-group" id="wasd-group">
      <div class="key-row"><div class="key" id="key-w">W</div></div>
      <div class="key-row">
        <div class="key" id="key-a">A</div>
        <div class="key" id="key-s">S</div>
        <div class="key" id="key-d">D</div>
      </div>
    </div>
    <div class="key-group" id="arrow-group">
      <div class="key-row"><div class="key" id="key-up">‚Üë</div></div>
      <div class="key-row">
        <div class="key" id="key-left">‚Üê</div>
        <div class="key" id="key-down">‚Üì</div>
        <div class="key" id="key-right">‚Üí</div>
      </div>
    </div>
  </div>
</div>

<div id="modal">
  <div id="modal-message"></div>
  <button onclick="restartGame()">OK</button>
</div>

<script>
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");
const cols = 20, rows = 20, cellSize = 30;
const goal = { x: cols - 1, y: 0 };
const start = { x: 0, y: 0 };
let grid = [], stack = [];
let current, genInterval;
let shortestPath = [];

let canMove = false;

function Cell(x, y) {
  this.x = x;
  this.y = y;
  this.walls = [true, true, true, true];
  this.visited = false;
  this.show = function () {
    const x = this.x * cellSize;
    const y = this.y * cellSize;
    ctx.strokeStyle = "#fff";
    ctx.lineWidth = 2;
    if (this.walls[0]) drawLine(x, y, x + cellSize, y);
    if (this.walls[1]) drawLine(x + cellSize, y, x + cellSize, y + cellSize);
    if (this.walls[2]) drawLine(x + cellSize, y + cellSize, x, y + cellSize);
    if (this.walls[3]) drawLine(x, y + cellSize, x, y);
  };
}

function drawLine(x1, y1, x2, y2) {
  ctx.beginPath();
  ctx.moveTo(x1, y1);
  ctx.lineTo(x2, y2);
  ctx.stroke();
}

function index(x, y) {
  if (x < 0 || y < 0 || x >= cols || y >= rows) return -1;
  return x + y * cols;
}

function removeWalls(a, b) {
  const dx = a.x - b.x;
  const dy = a.y - b.y;
  if (dx === 1) { a.walls[3] = false; b.walls[1] = false; }
  else if (dx === -1) { a.walls[1] = false; b.walls[3] = false; }
  if (dy === 1) { a.walls[0] = false; b.walls[2] = false; }
  else if (dy === -1) { a.walls[2] = false; b.walls[0] = false; }
}

function generateMaze() {
  grid = [];
  stack = [];
  for (let y = 0; y < rows; y++) {
    for (let x = 0; x < cols; x++) {
      grid.push(new Cell(x, y));
    }
  }
  current = grid[0];
  return new Promise(resolve => {
    genInterval = setInterval(() => {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      grid.forEach(c => c.show());
      current.visited = true;
      let neighbors = [];
      const dirs = [[0, -1], [1, 0], [0, 1], [-1, 0]];
      for (let [dx, dy] of dirs) {
        const neighbor = grid[index(current.x + dx, current.y + dy)];
        if (neighbor && !neighbor.visited) neighbors.push(neighbor);
      }
      if (neighbors.length > 0) {
        const next = neighbors[Math.floor(Math.random() * neighbors.length)];
        stack.push(current);
        removeWalls(current, next);
        current = next;
      } else if (stack.length > 0) {
        current = stack.pop();
      } else {
        clearInterval(genInterval);
        resolve();
      }
    }, 10);
  });
}

async function generateMazeUntilPathLongEnough(minLength = 110) {
  while (true) {
    await generateMaze();
    const path = bfs(start, goal);
    if (path.length >= minLength) {
      shortestPath = [];
      startGame();
      break;
    }
  }
}

let player = { x: 0, y: 0 };

// È¨º„Çí2‰Ωì„Å´„Åô„ÇãÔºàÂè≥‰∏ã„Å®Â∑¶‰∏ãÔºâ
let onis = [
  { x: cols - 1, y: rows - 1 }, // Âè≥‰∏ã
  { x: 0, y: rows - 1 }         // Â∑¶‰∏ã
];

let oniMoveCounter = 0;
const oniMoveInterval = 50;
let oniActive = false;
let gameOver = false;
let startTime, timerInterval;

function startGame() {
  player.x = start.x;
  player.y = start.y;
  canMove = true;
  setTimeout(() => { oniActive = true; }, 1000);
  startTime = Date.now();
  timerInterval = setInterval(() => {
    const elapsed = (Date.now() - startTime) / 1000;
    document.getElementById("timer").textContent = elapsed.toFixed(1);
  }, 100);
  loadRanking();
  requestAnimationFrame(gameLoop);
}

function gameLoop() {
  drawGame();
  if (oniActive && !gameOver) {
    oniMoveCounter++;
    if (oniMoveCounter >= oniMoveInterval) {
      moveOni();
      oniMoveCounter = 0;
    }
  }
  checkWinLose();
  if (!gameOver) requestAnimationFrame(gameLoop);
}

function moveOni() {
  onis.forEach(oni => {
    const dx = player.x - oni.x;
    const dy = player.y - oni.y;
    if (Math.abs(dx) > Math.abs(dy)) oni.x += Math.sign(dx);
    else oni.y += Math.sign(dy);
  });
}

function getNextOniPos(oni) {
  const dx = player.x - oni.x;
  const dy = player.y - oni.y;
  let nx = oni.x;
  let ny = oni.y;
  if (Math.abs(dx) > Math.abs(dy)) nx += Math.sign(dx);
  else ny += Math.sign(dy);
  return { x: nx, y: ny };
}

function drawGame() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  grid.forEach(c => c.show());

  ctx.fillStyle = "rgba(0,255,0,0.4)";
  for (const step of shortestPath) {
    ctx.fillRect(step.x * cellSize + 4, step.y * cellSize + 4, 22, 22);
  }

  ctx.fillStyle = "lime";
  ctx.fillRect(goal.x * cellSize + 8, goal.y * cellSize + 8, 14, 14);

  ctx.fillStyle = "blue";
  ctx.fillRect(player.x * cellSize + 8, player.y * cellSize + 8, 14, 14);

  onis.forEach(oni => {
    ctx.fillStyle = "red";
    ctx.fillRect(oni.x * cellSize + 8, oni.y * cellSize + 8, 14, 14);

    if (oniActive) {
      const next = getNextOniPos(oni);
      ctx.fillStyle = "rgba(255,0,0,0.5)";
      ctx.fillRect(next.x * cellSize + 10, next.y * cellSize + 10, 10, 10);
    }
  });

  drawMiniMap();
}

function checkWinLose() {
  for (const oni of onis) {
    if (player.x === oni.x && player.y === oni.y) {
      showModal("Êçï„Åæ„Å£„ÅüÔºÅ");
      return;
    }
  }
  if (player.x === goal.x && player.y === goal.y) {
    const time = (Date.now() - startTime) / 1000;
    saveRecord(time.toFixed(1));
    showModal(`„Ç¥„Éº„É´ÊàêÂäüÔºÅ\n\n„Çø„Ç§„É†: ${time.toFixed(1)}Áßí`);
  }
}

// BFSÊúÄÁü≠ÁµåË∑Ø
function bfs(start, end) {
  const visited = Array(rows).fill().map(() => Array(cols).fill(false));
  const queue = [[start.x, start.y, []]];
  while (queue.length > 0) {
    const [x, y, path] = queue.shift();
    if (x === end.x && y === end.y) return path;
    visited[y][x] = true;
    const cell = grid[index(x, y)];
    const dirs = [[0, -1, 0], [1, 0, 1], [0, 1, 2], [-1, 0, 3]];
    for (const [dx, dy, dir] of dirs) {
      const nx = x + dx, ny = y + dy;
      const ni = index(nx, ny);
      if (ni >= 0 && !visited[ny][nx] && !cell.walls[dir]) {
        queue.push([nx, ny, [...path, { x: nx, y: ny }]]);
      }
    }
  }
  return [];
}

function saveRecord(time) {
  let records = JSON.parse(localStorage.getItem("mazeRecords") || "[]");
  records.push(parseFloat(time));
  records.sort((a, b) => a - b);
  records = records.slice(0, 5);
  localStorage.setItem("mazeRecords", JSON.stringify(records));
  loadRanking();
}

function loadRanking() {
  const list = document.getElementById("ranking");
  const records = JSON.parse(localStorage.getItem("mazeRecords") || "[]");
  list.innerHTML = "";
  records.forEach(t => {
    const li = document.createElement("li");
    li.textContent = `${t} Áßí`;
    list.appendChild(li);
  });
}

function resetRanking() {
  localStorage.removeItem("mazeRecords");
  loadRanking();
}

function showModal(message) {
  document.getElementById("modal-message").innerHTML = message.replace(/\n/g, "<br>");
  document.getElementById("modal").style.display = "flex";
  gameOver = true;
  clearInterval(timerInterval);
}

function restartGame() {
  location.reload();
}

function showShortestPath() {
  shortestPath = bfs(player, goal);
}

// ==== „Éü„Éã„Éû„ÉÉ„Éó ====
const viewRadius = 6;
const miniCanvas = document.getElementById("mini-map");
const miniCtx = miniCanvas.getContext("2d");

function drawMiniMap() {
  const scale = cellSize;
  miniCtx.clearRect(0, 0, miniCanvas.width, miniCanvas.height);
  miniCtx.save();
  miniCtx.beginPath();
  miniCtx.arc(miniCanvas.width/2, miniCanvas.height/2, miniCanvas.width/2 - 2, 0, Math.PI*2);
  miniCtx.clip();
  for (let y = -viewRadius; y <= viewRadius; y++) {
    for (let x = -viewRadius; x <= viewRadius; x++) {
      const dist = Math.sqrt(x*x + y*y);
      if (dist <= viewRadius) {
        const gx = player.x + x;
        const gy = player.y + y;
        if (gx < 0 || gy < 0 || gx >= cols || gy >= rows) continue;
        const cell = grid[index(gx, gy)];
        miniCtx.fillStyle = "#111";
        miniCtx.fillRect(miniCanvas.width/2 + x*scale, miniCanvas.height/2 + y*scale, scale, scale);
        miniCtx.strokeStyle = "#fff";
        miniCtx.lineWidth = 1;
        if (cell.walls[0]) drawMiniLine(x, y, x+1, y);
        if (cell.walls[1]) drawMiniLine(x+1, y, x+1, y+1);
        if (cell.walls[2]) drawMiniLine(x+1, y+1, x, y+1);
        if (cell.walls[3]) drawMiniLine(x, y+1, x, y);
      }
    }
  }
  miniCtx.fillStyle = "blue";
  miniCtx.fillRect(miniCanvas.width/2, miniCanvas.height/2, scale, scale);
  miniCtx.restore();
}

function drawMiniLine(x1, y1, x2, y2) {
  const scale = cellSize;
  miniCtx.beginPath();
  miniCtx.moveTo(miniCanvas.width/2 + x1*scale, miniCanvas.height/2 + y1*scale);
  miniCtx.lineTo(miniCanvas.width/2 + x2*scale, miniCanvas.height/2 + y2*scale);
  miniCtx.stroke();
}

// ==== „Ç≠„ÉºÊäº‰∏ãË°®Á§∫ ====
const pressedKeys = {};
function updateKeyDisplay() {
  ["w","a","s","d","ArrowUp","ArrowLeft","ArrowDown","ArrowRight"].forEach(k => {
    const idMap = {
      "w":"key-w","a":"key-a","s":"key-s","d":"key-d",
      "ArrowUp":"key-up","ArrowLeft":"key-left","ArrowDown":"key-down","ArrowRight":"key-right"
    };
    const el = document.getElementById(idMap[k]);
    if (el) {
      if (pressedKeys[k]) el.classList.add("pressed");
      else el.classList.remove("pressed");
    }
  });
}

document.addEventListener("keydown", e => {
  if (!canMove || gameOver) return;
  pressedKeys[e.key] = true;
  updateKeyDisplay();
  const cell = grid[index(player.x, player.y)];
  if (e.key === "ArrowUp" || e.key === "w") {
    if (!cell.walls[0]) player.y--;
  } else if (e.key === "ArrowDown" || e.key === "s") {
    if (!cell.walls[2]) player.y++;
  } else if (e.key === "ArrowLeft" || e.key === "a") {
    if (!cell.walls[3]) player.x--;
  } else if (e.key === "ArrowRight" || e.key === "d") {
    if (!cell.walls[1]) player.x++;
  }
});
document.addEventListener("keyup", e => {
  pressedKeys[e.key] = false;
  updateKeyDisplay();
});

generateMazeUntilPathLongEnough();
</script>
</body>
</html>
